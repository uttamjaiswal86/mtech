<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Linear Algebra Visualizer (Corrected)</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d0d0d; font-family: 'Segoe UI', sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            width: 340px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 { font-size: 18px; margin: 0 0 15px 0; color: #4facfe; border-bottom: 1px solid #444; padding-bottom: 10px; }
        
        .control-label { font-size: 11px; color: #888; text-transform: uppercase; font-weight: bold; margin-top: 10px; display: block; }
        
        select {
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 13px;
            cursor: pointer;
        }

        .matrix-display {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 14px;
            border: 1px solid #333;
            min-height: 60px;
        }

        input[type=range] {
            width: 100%;
            margin-bottom: 15px;
            cursor: pointer;
            accent-color: #4facfe;
        }

        .status-box {
            background: #222;
            padding: 12px;
            border-left: 4px solid #4facfe;
            font-size: 12px;
            line-height: 1.5;
            color: #ddd;
        }

        .highlight { color: #4facfe; font-weight: bold; }
        .legend-item { display: flex; align-items: center; font-size: 11px; color: #aaa; margin-top: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; }

        /* Mode-specific styling */
        .mode-2d { border-left-color: #ffcc00; }
        .mode-3d { border-left-color: #00ff00; }
        .mode-spec { border-left-color: #ff4444; }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-panel">
        <h1>Linear Algebra Laboratory</h1>
        
        <span class="control-label">Select Visualization Mode</span>
        <select id="modeSelect">
            <option value="2d">2D Grid Transform (The Classic)</option>
            <option value="3d">3D Space Transform (The Volume)</option>
            <option value="spectral">Spectral Decomposition (The Theorem)</option>
        </select>

        <span class="control-label">Matrix Preset</span>
        <select id="presetSelect">
            </select>

        <div class="matrix-display" id="matrixTex">
            \[ I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} \]
        </div>

        <span class="control-label">Transformation Progress</span>
        <input type="range" id="animSlider" min="0" max="1" step="0.01" value="0">

        <div class="status-box" id="statusText">
            Select a mode to begin exploring.
        </div>
        
        <div id="legendContainer" style="margin-top: 15px; font-size: 11px; color: #666; border-top: 1px solid #333; padding-top: 10px; display:none;">
             </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL STATE ---
        const state = {
            mode: '2d', // '2d', '3d', 'spectral'
            t: 0,
            matrixA: new THREE.Matrix4(), // The active transform
            objects: [], // Store animated objects for clean up
            presets: {
                '2d': [
                    // CORRECTED: Vertical Shear (X-axis moves)
                    { name: 'Vertical Shear (X moves)', mat: [1, 0, 1, 1], tex: '\\begin{bmatrix} 1 & 0 \\\\ 1 & 1 \\end{bmatrix}' },
                    { name: 'Rotation (90Â°)', mat: [0, -1, 1, 0], tex: '\\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}' },
                    { name: 'Scaling (2x, 0.5y)', mat: [2, 0, 0, 0.5], tex: '\\begin{bmatrix} 2 & 0 \\\\ 0 & 0.5 \\end{bmatrix}' },
                    { name: 'Determinant 0 (Collapse)', mat: [1, 1, 2, 2], tex: '\\begin{bmatrix} 1 & 1 \\\\ 2 & 2 \\end{bmatrix}' }
                ],
                '3d': [
                    { name: 'Shear + Rotate', mat: [1, 1, 0, 0, 1, 0, 0, 0, 1], tex: '\\text{Shear} \\times \\text{Identity}' }, 
                    { name: 'Rank 2 (Squash)', mat: [1, 0, -1, 0, 1, -1, 1, 1, -2], tex: '\\text{Rank 2 Projection}' },
                    { name: 'Rank 1 (Line)', mat: [1, 1, 1, 2, 2, 2, 3, 3, 3], tex: '\\text{Rank 1 Projection}' }
                ],
                'spectral': [
                    { name: 'Symmetric Matrix', mat: [], tex: 'A = Q \\Lambda Q^T' }
                ]
            }
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d0d0d);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- HELPERS ---
        // A unified root object for the current visualization
        let vizRoot = new THREE.Group();
        scene.add(vizRoot);

        // Helper to dispose of geometries and materials (Prevents Memory Leak)
        function disposeHierarchy(node) {
            for (let i = node.children.length - 1; i >= 0; i--) {
                const child = node.children[i];
                disposeHierarchy(child);
                node.remove(child);
            }
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
                if (Array.isArray(node.material)) {
                    node.material.forEach(m => m.dispose());
                } else {
                    node.material.dispose();
                }
            }
        }

        function cleanScene() {
            disposeHierarchy(vizRoot);
            scene.remove(vizRoot);
            vizRoot = new THREE.Group();
            scene.add(vizRoot);
            state.objects = [];
        }

        // --- MODE BUILDERS ---

        // 1. 2D DEPICTION
        function build2D() {
            // Camera looking top-down but slight angle
            camera.position.set(0, 0, 15);
            camera.lookAt(0,0,0);
            controls.reset();
            camera.position.set(0, 0, 12);

            // Add Background Grid (Fixed)
            const bgGrid = new THREE.GridHelper(20, 20, 0x222222, 0x111111);
            bgGrid.rotation.x = -Math.PI / 2; // Flat on XY plane
            bgGrid.position.z = -0.1;
            vizRoot.add(bgGrid);

            // Add Transformable Grid
            const lines = new THREE.Group();
            const material = new THREE.LineBasicMaterial({ color: 0x4facfe, transparent: true, opacity: 0.5 });
            
            const size = 5;
            const divisions = 10;
            
            // Collect vertices for lines
            const points = [];
            // Horizontal lines
            for(let y = -size; y <= size; y += 1) {
                points.push(new THREE.Vector3(-size, y, 0));
                points.push(new THREE.Vector3(size, y, 0));
            }
            // Vertical lines
            for(let x = -size; x <= size; x += 1) {
                points.push(new THREE.Vector3(x, -size, 0));
                points.push(new THREE.Vector3(x, size, 0));
            }

            points.forEach((p, i) => {
                if(i % 2 === 0) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([points[i], points[i+1]]);
                    const line = new THREE.Line(geometry, material);
                    // Store original positions for animation
                    line.userData.p0 = points[i].clone();
                    line.userData.p1 = points[i+1].clone();
                    lines.add(line);
                    state.objects.push(line);
                }
            });
            vizRoot.add(lines);

            // Basis Vectors (i and j)
            const iHat = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0xff0000);
            const jHat = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1, 0x00ff00);
            
            iHat.userData.isVector = true; iHat.userData.orig = new THREE.Vector3(1,0,0);
            jHat.userData.isVector = true; jHat.userData.orig = new THREE.Vector3(0,1,0);
            
            vizRoot.add(iHat);
            vizRoot.add(jHat);
            state.objects.push(iHat, jHat);

            // Legend
            const legend = document.getElementById('legendContainer');
            legend.style.display = 'block';
            legend.innerHTML = `
                <div class="legend-item"><div class="dot" style="background:#ff0000;"></div>Basis \(\\hat{i}\) (1, 0)</div>
                <div class="legend-item"><div class="dot" style="background:#00ff00;"></div>Basis \(\\hat{j}\) (0, 1)</div>
            `;
        }

        // 2. 3D DEPICTION
        function build3D() {
            camera.position.set(10, 8, 10);
            camera.lookAt(0,0,0);

            const axes = new THREE.AxesHelper(2);
            vizRoot.add(axes);
            
            // Point Cloud Grid
            const gap = 0.5;
            const geom = new THREE.SphereGeometry(0.08, 8, 8);
            
            for(let x = -2; x <= 2; x += gap) {
                for(let y = -2; y <= 2; y += gap) {
                    for(let z = -2; z <= 2; z += gap) {
                        const r = (x + 2) / 4; 
                        const g = (y + 2) / 4;
                        const b = (z + 2) / 4;
                        const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color(r, g, b) });
                        const dot = new THREE.Mesh(geom, mat);
                        
                        // ThreeJS Y-up adjustment: Map math Z to Three Y
                        dot.position.set(x, z, y); 
                        dot.userData.orig = new THREE.Vector3(x, z, y);
                        
                        vizRoot.add(dot);
                        state.objects.push(dot);
                    }
                }
            }

            // Ghost Box for volume reference
            const box = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4)), 0x333333);
            vizRoot.add(box);

            document.getElementById('legendContainer').style.display = 'none';
        }

        // 3. SPECTRAL DECOMPOSITION
        function buildSpectral() {
            camera.position.set(6, 6, 8);
            camera.lookAt(0,0,0);
            
            const grid = new THREE.GridHelper(10, 10, 0x333333, 0x111111);
            vizRoot.add(grid);

            // Create Sphere Group
            const sphereGroup = new THREE.Group();
            
            // Wireframe Sphere
            const sGeom = new THREE.SphereGeometry(1.5, 24, 24);
            const sMat = new THREE.MeshBasicMaterial({ color: 0x666666, wireframe: true, transparent: true, opacity: 0.2 });
            const sphere = new THREE.Mesh(sGeom, sMat);
            sphereGroup.add(sphere);

            // Axes
            const addAxis = (dir, col) => {
                const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 2.5, col);
                sphereGroup.add(arrow);
            };
            addAxis(new THREE.Vector3(1,0,0), 0xff4444);
            addAxis(new THREE.Vector3(0,1,0), 0x44ff44);
            addAxis(new THREE.Vector3(0,0,1), 0x4444ff);

            vizRoot.add(sphereGroup);
            state.objects.push(sphereGroup); // We will animate the group matrix

            // Setup Matrices for Spectral
            // Q (Rotation), Lambda (Scale), QT
            const rotY = new THREE.Matrix4().makeRotationY(Math.PI / 4);
            const rotZ = new THREE.Matrix4().makeRotationZ(Math.PI / 8);
            const Q = new THREE.Matrix4().multiplyMatrices(rotY, rotZ);
            const L = new THREE.Matrix4().makeScale(2.5, 1.0, 0.5);
            const QT = Q.clone().transpose();

            // Store for animation loop
            state.spectralMatrices = { Q, L, QT };
            
            const legend = document.getElementById('legendContainer');
            legend.style.display = 'block';
            legend.innerHTML = `
                <div class="legend-item"><div class="dot" style="background:#ff4444;"></div>Eigenvector 1 (Stretch)</div>
                <div class="legend-item"><div class="dot" style="background:#4444ff;"></div>Eigenvector 2 (Squash)</div>
            `;
        }

        // --- UPDATE LOGIC ---

        function update2D(t) {
            // Matrix A is 4x4 but we only care about x,y transform
            const mat = state.matrixA; // User selected
            
            state.objects.forEach(obj => {
                if (obj.userData.isVector) {
                    // It's an ArrowHelper
                    const pOrig = obj.userData.orig.clone();
                    // Lerp vectors: I + (A-I)t = I(1-t) + At
                    const pFinal = pOrig.clone().applyMatrix4(mat);
                    const pCurr = new THREE.Vector3().lerpVectors(pOrig, pFinal, t);
                    
                    obj.setDirection(pCurr.clone().normalize());
                    obj.setLength(pCurr.length());
                } else {
                    // It's a line segment
                    const geom = obj.geometry;
                    const pos = geom.attributes.position;
                    
                    // Transform start and end points
                    const p0 = obj.userData.p0.clone().applyMatrix4(mat);
                    const p1 = obj.userData.p1.clone().applyMatrix4(mat);
                    
                    const c0 = new THREE.Vector3().lerpVectors(obj.userData.p0, p0, t);
                    const c1 = new THREE.Vector3().lerpVectors(obj.userData.p1, p1, t);
                    
                    pos.setXYZ(0, c0.x, c0.y, c0.z);
                    pos.setXYZ(1, c1.x, c1.y, c1.z);
                    pos.needsUpdate = true;
                }
            });
        }

        function update3D(t) {
            const mat = state.matrixA;
            state.objects.forEach(obj => {
                const pStart = obj.userData.orig;
                const pEnd = pStart.clone().applyMatrix4(mat);
                obj.position.lerpVectors(pStart, pEnd, t);
            });
        }

        function updateSpectral(t) {
            // t is 0 to 3
            const { Q, L, QT } = state.spectralMatrices;
            const group = state.objects[0]; // The sphere group
            
            let currentMat = new THREE.Matrix4();
            let msg = "";

            if (t <= 1) {
                // Identity -> QT
                const qId = new THREE.Quaternion();
                const qT = new THREE.Quaternion().setFromRotationMatrix(QT);
                const qRes = new THREE.Quaternion().slerpQuaternions(qId, qT, t);
                currentMat.makeRotationFromQuaternion(qRes);
                msg = "Step 1: Rotate to align with Eigenvectors";
            } else if (t <= 2) {
                const t2 = t - 1;
                // Scale * QT
                const sX = THREE.MathUtils.lerp(1, 2.5, t2);
                const sY = THREE.MathUtils.lerp(1, 1.0, t2);
                const sZ = THREE.MathUtils.lerp(1, 0.5, t2);
                const S = new THREE.Matrix4().makeScale(sX, sY, sZ);
                currentMat.multiplyMatrices(S, QT);
                msg = "Step 2: Scale along the axes";
            } else {
                const t3 = t - 2;
                // Q * Scale * QT
                const base = new THREE.Matrix4().multiplyMatrices(L, QT);
                const qId = new THREE.Quaternion();
                const qTarget = new THREE.Quaternion().setFromRotationMatrix(Q);
                const qRes = new THREE.Quaternion().slerpQuaternions(qId, qTarget, t3);
                const rot = new THREE.Matrix4().makeRotationFromQuaternion(qRes);
                currentMat.multiplyMatrices(rot, base);
                msg = "Step 3: Rotate back to original frame";
            }

            group.matrixAutoUpdate = false;
            group.matrix.copy(currentMat);
            
            document.getElementById('statusText').innerHTML = msg;
        }

        // --- UI HANDLERS ---
        const modeSelect = document.getElementById('modeSelect');
        const presetSelect = document.getElementById('presetSelect');
        const slider = document.getElementById('animSlider');
        const matrixTex = document.getElementById('matrixTex');
        const statusBox = document.getElementById('statusText');

        function populatePresets(mode) {
            presetSelect.innerHTML = "";
            state.presets[mode].forEach((p, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.text = p.name;
                presetSelect.add(opt);
            });
            loadPreset(0);
        }

        function loadPreset(idx) {
            const mode = state.mode;
            const data = state.presets[mode][idx];
            
            // Set Tex
            matrixTex.innerHTML = `\\[ ${data.tex} \\]`;
            if(window.MathJax) MathJax.typesetPromise();

            // Set Matrix A logic
            if(mode === '2d') {
                // 2x2 mat [a b c d] -> 4x4
                const m = data.mat;
                // ThreeJS Matrix4 is set(n11, n12...) row major
                // 2D Matrix: | m[0] m[1] |
                //            | m[2] m[3] |
                state.matrixA.set(
                    m[0], m[1], 0, 0,
                    m[2], m[3], 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                );
            } else if (mode === '3d') {
                const m = data.mat;
                state.matrixA.set(
                    m[0], m[1], m[2], 0,
                    m[3], m[4], m[5], 0,
                    m[6], m[7], m[8], 0,
                    0, 0, 0, 1
                );
            }
            
            // Reset Animation
            slider.value = 0;
            updateAnimation(0);
        }

        function switchMode() {
            state.mode = modeSelect.value;
            cleanScene();
            
            // Slider config
            if(state.mode === 'spectral') {
                slider.max = 3;
                statusBox.className = "status-box mode-spec";
                buildSpectral();
            } else {
                slider.max = 1;
                statusBox.className = state.mode === '2d' ? "status-box mode-2d" : "status-box mode-3d";
                if(state.mode === '2d') build2D();
                else build3D();
            }

            populatePresets(state.mode);
        }

        function updateAnimation(val) {
            const t = parseFloat(val);
            if (state.mode === '2d') {
                update2D(t);
                statusBox.innerHTML = t === 0 ? "Identity (Basis vectors aligned)" : 
                                     t === 1 ? "Transformed (Basis vectors mapped)" : 
                                     "Transforming grid...";
            } else if (state.mode === '3d') {
                update3D(t);
                statusBox.innerHTML = t === 0 ? "Original Space (Grid Cube)" : 
                                     t === 1 ? "Transformed Space" : 
                                     "Warping space...";
            } else {
                updateSpectral(t);
            }
        }

        // Listeners
        modeSelect.addEventListener('change', switchMode);
        presetSelect.addEventListener('change', (e) => loadPreset(e.target.value));
        slider.addEventListener('input', (e) => updateAnimation(e.target.value));

        // Init
        switchMode();
        // Initial MathJax render for safety
        window.addEventListener('load', () => {
             if(window.MathJax) MathJax.typesetPromise();
        });

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>